; Tells Simplify that multiplication is commutative.
(BG_PUSH (FORALL (a b) (EQ (* a b) (* b a))))

; Array slice product definition
(BG_PUSH
  (FORALL (b i j)
    (AND
      (IMPLIES
        (> i j)
        (EQ (prod b i j) 1)
      )
      (IMPLIES
        (<= i j)
        (EQ (prod b i j) (* (select b i) (prod b (+ i 1) j)))
      )
    )
  )
)

; using DO theorem, we get predicates

; Q => wp(I, P)
(IMPLIES
  (AND (<= 0 n) (EQ b B))
  (AND (EQ b B) (<= (- 0 1) (- n 1)) (< (- n 1) n) (EQ 1 (prod B (+ (- n 1) 1) (- n 1))))
)

; P ^ B => wp(S, P)
(IMPLIES
  (AND
    (EQ b B)
    (<= (- 0 1) i)
    (< i n)
    (EQ s (prod B (+ i 1) (- n 1)))
    (NEQ i (- 0 1))
  )
  (AND
    (EQ b B)
    (<= (- 0 1) (- i 1))
    (< (- i 1) n)
    (EQ
      (* s (select b i))
      (prod B (+ (- i 1) 1) (- n 1))
    )
  )
)

; P ^ ~B => R
(IMPLIES
  (AND (EQ b B) (<= (- 0 1) i) (< i n) (EQ s (prod B (+ i 1) (- n 1))) (NOT (NEQ i (- 0 1))))
  (EQ s (prod B 0 (- n 1)))
)

; P ^ B => t > 0
(IMPLIES
  (AND (EQ b B) (<= (- 0 1) i) (< i n) (EQ s (prod B (+ i 1) (- n 1))) (NEQ i (- 0 1)))
  (> (+ i 1) 0)
)

; P ^ B => wp("t0 := t; S", t < t0)
(IMPLIES
  (AND (EQ b B) (<= (- 0 1) i) (< i n) (EQ s (prod B (+ i 1) (- n 1))) (NEQ i (- 0 1))) 
  (< (+ (- i 1) 1) (+ i 1))
)
