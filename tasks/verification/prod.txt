; Array slice product definition
(BG_PUSH
  (FORALL (b i j)
    (AND
      (IMPLIES
        (> i j)
        (EQ (prod b i j) 1)
      )
      (IMPLIES
        (<= i j)
        (EQ (prod b i j) (* (select b j) (prod b i (- j 1))))
      )
    )
  )
)

; using DO theorem, we get predicates

; Q => wp(I, P)
(IMPLIES
  (AND (<= 0 n) (EQ b B))
  (AND (EQ b B) (<= 0 0) (<= 0 n) (EQ 1 (prod B 0 (- 0 1))))
)

; P ^ B => wp(S, P)
(IMPLIES
  (AND
    (EQ b B)
    (<= 0 i)
    (<= i n)
    (EQ p (prod B 0 (- i 1)))
    (NEQ i n)
  )
  (AND
    (EQ b B)
    (<= 0 (+ i 1))
    (<= (+ i 1) n)
    (EQ
      (* p (select b i))
      (prod B 0 i)
    )
  )
)

; P ^ ~B => R
(IMPLIES
  (AND (EQ b B) (<= 0 i) (<= i n) (EQ p (prod B 0 (- i 1))) (NOT (NEQ i n)))
  (EQ p (prod B 0 (- n 1)))
)

; P ^ B => t > 0
(IMPLIES
  (AND (EQ b B) (<= 0 i) (<= i n) (EQ p (prod B 0 (- i 1))) (NEQ i n))
  (> (- n i) 0)
)

; P ^ B => wp("t0 := t; S", t < t0)
(IMPLIES
  (AND (EQ b B) (<= 0 i) (<= i n) (EQ p (prod B 0 (- i 1))) (NEQ i n))
  (< (- n (+ i 1)) (- n i)) 
)
