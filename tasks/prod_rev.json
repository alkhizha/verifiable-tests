{
    "name" : "prod_rev",
    "description" : "Програма повинна обчислювати добуток всіх елементів масиву b. (Зауважте, що добуток нуля элементів дорівнює 1.)",
    "human_readable_precondition" : "n ≥ 0 ∧ b[0:n-1] = B[0:n-1]",
    "simplify_precondition" : "(AND (<= 0 n) (EQ b B))",
    "human_readable_postcondition" : "p = (Π k : 0 ≤ k < n : B[k])",
    "simplify_postcondition" : "(EQ p (prod B 0 (- n 1)))",
    "human_readable_loop_invariant" : "-1 ≤ i < n ∧ b[0:n-1] = B[0:n-1] ∧ p = (Π k : i < k < n : B[k])",
    "simplify_loop_invariant" : "(AND (<= (- 0 1) i) (< i n) (EQ b B) (EQ p (prod B (+ i 1) (- n 1))))",
    "human_readable_boundary_function" : "i + 1",
    "simplify_boundary_function" : "(+ i 1)",
    "simplify_definitions" : "(BG_PUSH (FORALL (a b) (EQ (* a b) (* b a)))) (BG_PUSH (FORALL (b i j) (AND (IMPLIES (> i j) (EQ (prod b i j) 1)) (IMPLIES (<= i j) (EQ (prod b i j) (* (select b j) (prod b i (- j 1))))))))"
}

/*
"simplify_definitions" with decent formatting.
The first axiom ensures multiplication commutativity.
The second axiom defines the operation of array slice product.

(BG_PUSH (FORALL (a b) (EQ (* a b) (* b a))))

(BG_PUSH
  (FORALL (b i j)
    (AND
      (IMPLIES
        (> i j)
        (EQ (prod b i j) 1)
      )
      (IMPLIES
        (<= i j)
        (EQ (prod b i j) (* (select b j) (prod b i (- j 1))))
      )
    )
  )
)

*/