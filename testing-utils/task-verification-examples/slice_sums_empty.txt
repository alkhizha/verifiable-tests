(BG_PUSH
  (FORALL (b i j) (PATS (sum b i j))
    (AND
      (IMPLIES
        (> i j)
        (EQ (sum b i j) 0))
      (IMPLIES
        (<= i j)
        (EQ
          (sum b i j)
          (+ (select b j) (sum b i (- j 1))) )))))

(DEFPRED (Q n b B) (AND (< 0 n) (EQ b B)))

(DEFPRED (IF_CONDITION_1 n) (EQ n 0))

(DEFPRED (IF_CONDITION_2 n) (NEQ n 0))

(DEFPRED (R n b B)
  (FORALL (k)
    (IMPLIES
      (AND (<= 0 k) (< k n))
      (EQ (select b k) (sum B 0 k)) )))

(DEFPRED (P n b B i)
  (AND
    (<= 1 i) (<= i n)
    (FORALL (k)
      (IMPLIES
        (AND (<= 0 k) (< k i))
        (EQ (select b k) (sum B 0 k)) ))
    (FORALL (k)
      (IMPLIES
        (AND (<= i k) (< k n))
        (EQ (select b k) (select B k)) ))))

(BG_PUSH (FORALL (n i) (EQ (t n i) (- n i))))

(DEFPRED (LOOP_CONDITION n i) (NEQ i n))

; Ожидаемый вид программы:
;
; if
;   n = 0  ->  skip
;   n > 0  ->  i := 1;
;              do
;                 i != n  ->  i, b[i] := i+1, b[i-1] + b[i]
;              od
; fi

; Пользуемся теоремой IF

(IMPLIES (Q n b B) (OR (IF_CONDITION_1 n) (IF_CONDITION_2 n)))

(IMPLIES
  (AND (Q n b B) (IF_CONDITION_1 n))
  (R n b B))

; Во второй ветке пользуемся теоремой DO

(IMPLIES
  (AND (Q n b B) (IF_CONDITION_2 n))
  (P n b B 1))

(IMPLIES
  (AND (P n b B i) (LOOP_CONDITION n i))
  (P n (store b i (+ (select b i) (select b (- i 1)))) B (+ i 1)))

(IMPLIES
  (AND (P n b B i) (NOT (LOOP_CONDITION n i)))
  (R n b B))

(IMPLIES
  (AND (P n b B i) (LOOP_CONDITION n i))
  (> (t n i) 0))

(IMPLIES
  (AND (P n b B i) (LOOP_CONDITION n i))
  (< (t n (+ i 1)) (t n i)))
